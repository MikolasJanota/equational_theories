#!/usr/bin/env python3
"""This scripts allows given a left_eqn and a right_eqn, to generate an SMT2
file to look for a counterexample to left_eqn => right_eqn, i.e. look for
left_eqn AND NOT right_eqn.

This
script requires the Z3 python bindings and passing in the equation
numbers on the command line. It depends on the `generate_eqs_list`
script.
"""

import argparse
import sys
from datetime import datetime

from z3 import (
    Const,
    DeclareSort,
    Exists,
    ExprRef,
    ForAll,
    Function,
    IntSort,
    Not,
    Solver,
    is_const,
)

from generate_eqs_list import VAR_NAMES, eqs, format_expr


def tup_to_term(tup):
    if isinstance(tup, int):
        return Const(VAR_NAMES[tup], S)
    elif isinstance(tup, tuple):
        assert len(tup) == 2
        return m(tup_to_term(tup[0]), tup_to_term(tup[1]))
    else:
        raise ValueError("Expected an int or a tuple")


def eqn_to_z3(tup):
    assert len(tup) == 2
    left, right = tup
    return tup_to_term(left) == tup_to_term(right)


def get_vars(t: ExprRef):
    all_vars = set()
    if is_const(t):
        all_vars.add(t)
    else:
        for u in t.children():
            all_vars = all_vars.union(get_vars(u))
    return all_vars


def Univ(t: ExprRef):
    return ForAll(list(get_vars(t)), t)


def Exi(t: ExprRef):
    return Exists(list(get_vars(t)), t)


def print_file(left, right):
    tup_l = eqs[left - 1]
    tup_r = eqs[right - 1]
    left_eq = eqn_to_z3(tup_l)
    right_eq = eqn_to_z3(tup_r)
    s = Solver()
    s.add(Univ(left_eq))
    s.add(Exi(Not(right_eq)))
    return f"""\
; generated by {sys.argv[0]} on {datetime.today().strftime('%Y-%m-%d')}
; {left} AND not {right}
; {format_expr(tup_l)} AND not {format_expr(tup_r)}
{s.to_smt2()}"""


def run_main():
    global S, m
    arg_parser = argparse.ArgumentParser()
    arg_parser.add_argument(
        "left",
        help="id of left equation",
        type=int,
    )
    arg_parser.add_argument(
        "right",
        help="id of right equation",
        type=int,
    )
    arg_parser.add_argument("-i", "--ints", help="use ints", action="store_true")
    args = arg_parser.parse_args()
    S = IntSort() if args.ints else DeclareSort("S")
    m = Function("m", S, S, S)
    print(print_file(args.left, args.right))


if __name__ == "__main__":
    run_main()
